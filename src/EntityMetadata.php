<?php
	
	/*
	 * ╔═══════════════════════════════════════════════════════════════════════════════════════╗
	 * ║                                                                                       ║
	 * ║   ██████╗ ██████╗      ██╗███████╗ ██████╗████████╗ ██████╗ ██╗   ██╗███████╗██╗      ║
	 * ║  ██╔═══██╗██╔══██╗     ██║██╔════╝██╔════╝╚══██╔══╝██╔═══██╗██║   ██║██╔════╝██║      ║
	 * ║  ██║   ██║██████╔╝     ██║█████╗  ██║        ██║   ██║   ██║██║   ██║█████╗  ██║      ║
	 * ║  ██║   ██║██╔══██╗██   ██║██╔══╝  ██║        ██║   ██║▄▄ ██║██║   ██║██╔══╝  ██║      ║
	 * ║  ╚██████╔╝██████╔╝╚█████╔╝███████╗╚██████╗   ██║   ╚██████╔╝╚██████╔╝███████╗███████╗ ║
	 * ║   ╚═════╝ ╚═════╝  ╚════╝ ╚══════╝ ╚═════╝   ╚═╝    ╚══▀▀═╝  ╚═════╝ ╚══════╝╚══════╝ ║
	 * ║                                                                                       ║
	 * ║  ObjectQuel - Powerful Object-Relational Mapping built on the Data Mapper pattern     ║
	 * ║                                                                                       ║
	 * ║  Clean separation between entities and persistence logic with an intuitive,           ║
	 * ║  object-oriented query language. Powered by CakePHP's robust database foundation.     ║
	 * ║                                                                                       ║
	 * ╚═══════════════════════════════════════════════════════════════════════════════════════╝
	 */

	namespace Quellabs\ObjectQuel;
	
	use Quellabs\AnnotationReader\Collection\AnnotationCollection;
	use Quellabs\ObjectQuel\Annotations\Orm\Column;
	use Quellabs\ObjectQuel\Annotations\Orm\Index;
	use Quellabs\ObjectQuel\Annotations\Orm\OneToMany;
	use Quellabs\ObjectQuel\Annotations\Orm\OneToOne;
	use Quellabs\ObjectQuel\Annotations\Orm\ManyToOne;
	use Quellabs\ObjectQuel\Annotations\Orm\UniqueIndex;
	use Quellabs\ObjectQuel\Annotations\Orm\Version;
	
	/**
	 * Immutable value object containing all metadata for a single entity.
	 *
	 * This class consolidates all entity metadata that was previously scattered across
	 * multiple cache arrays in EntityStore. It is built once per entity and cached
	 * by EntityStore, eliminating the need for multiple cache lookups and providing
	 * a single, type-safe interface for accessing entity information.
	 *
	 * All properties are readonly to ensure immutability and prevent accidental
	 * modification of cached metadata.
	 */
	readonly class EntityMetadata {
		
		/**
		 * Constructor for EntityMetadata.
		 *
		 * @param string $className Fully qualified, normalized class name
		 * @param string $tableName Database table name from @Table annotation
		 * @param array<string, mixed> $properties Property names and their reflection info
		 * @param array<string, AnnotationCollection> $annotations Property name => annotation collection mapping
		 * @param array<string, string> $columnMap Property name => column name mapping
		 * @param array<string> $identifierKeys Property names that serve as primary keys
		 * @param array<string> $identifierColumns Column names that serve as primary keys
		 * @param array<string, array{name: string, column: Column, version: Version}> $versionColumns Properties with version tracking
		 * @param array<string, ManyToOne> $manyToOneRelations Property => ManyToOne annotation mapping
		 * @param array<string, OneToMany> $oneToManyRelations Property => OneToMany annotation mapping
		 * @param array<string, OneToOne> $oneToOneRelations Property => OneToOne annotation mapping
		 * @param array<Index|UniqueIndex> $indexes Index annotations from class level
		 * @param string|null $autoIncrementColumn Property name of auto-increment primary key (if any)
		 * @param array<string, array> $columnDefinitions Full column definitions for schema generation
		 */
		public function __construct(
			public string  $className,
			public string  $tableName,
			public array   $properties,
			public array   $annotations,
			public array   $columnMap,
			public array   $identifierKeys,
			public array   $identifierColumns,
			public array   $versionColumns,
			public array   $manyToOneRelations,
			public array   $oneToManyRelations,
			public array   $oneToOneRelations,
			public array   $indexes,
			public ?string $autoIncrementColumn,
			public array   $columnDefinitions,
		) {}
		
		/**
		 * Retrieves the primary key of the entity.
		 * For composite primary keys, returns the first key.
		 *
		 * @return string|null The primary key property name, or null if no primary key exists
		 */
		public function getPrimaryKey(): ?string {
			return $this->identifierKeys[0] ?? null;
		}
		
		/**
		 * Check if this entity has an auto-increment primary key.
		 * An auto-increment key is one that is automatically generated by the database.
		 *
		 * @return bool True if the entity has an auto-increment primary key, false otherwise
		 */
		public function hasAutoIncrementPrimaryKey(): bool {
			return $this->autoIncrementColumn !== null;
		}
		
		/**
		 * Retrieve the ManyToOne dependencies for this entity.
		 * These represent entities that this entity has a foreign key reference to.
		 *
		 * @return ManyToOne[] Array of ManyToOne annotations
		 */
		public function getManyToOneDependencies(): array {
			return array_values($this->manyToOneRelations);
		}
		
		/**
		 * Retrieve the OneToOne dependencies where this entity is the owning side.
		 * Only returns OneToOne relations that have an inversedBy property set,
		 * indicating this entity owns the relationship.
		 *
		 * @return OneToOne[] Array of OneToOne annotations for owned relationships
		 */
		public function getOneToOneDependencies(): array {
			return array_filter($this->oneToOneRelations, fn($relation) => !empty($relation->getInversedBy()));
		}
		
		/**
		 * Obtains the database column name for a given property.
		 *
		 * @param string $property The entity property name
		 * @return string|null The corresponding column name, or null if property doesn't have a column mapping
		 */
		public function getColumnName(string $property): ?string {
			return $this->columnMap[$property] ?? null;
		}
		
		/**
		 * Obtains the entity property name for a given database column.
		 *
		 * @param string $columnName The database column name
		 * @return string|null The corresponding property name, or null if column doesn't map to a property
		 */
		public function getPropertyName(string $columnName): ?string {
			$flipped = array_flip($this->columnMap);
			return $flipped[$columnName] ?? null;
		}
		
		/**
		 * Checks if a property is part of the entity's primary key.
		 *
		 * @param string $property The property name to check
		 * @return bool True if the property is a primary key, false otherwise
		 */
		public function isIdentifierKey(string $property): bool {
			return in_array($property, $this->identifierKeys, true);
		}
		
		/**
		 * Checks if a property has version tracking enabled.
		 * Version tracking is used for optimistic locking.
		 *
		 * @param string $property The property name to check
		 * @return bool True if the property has version tracking, false otherwise
		 */
		public function isVersioned(string $property): bool {
			return isset($this->versionColumns[$property]);
		}
		
		/**
		 * Normalizes the primary key into an array.
		 * This function checks if the given primary key is already an array.
		 * If not, it converts the primary key into an array with the proper key
		 * based on the entity's identifier keys.
		 *
		 * @param mixed $primaryKey The primary key to be normalized
		 * @return array A normalized representation of the primary key as an array
		 */
		public function formatPrimaryKeyAsArray(mixed $primaryKey): array {
			// If the primary key is already an array, return it directly
			if (is_array($primaryKey)) {
				return $primaryKey;
			}
			
			// Otherwise, get the first identifier key and create an array with the proper key and value
			$firstKey = $this->identifierKeys[0] ?? null;
			return $firstKey ? [$firstKey => $primaryKey] : [];
		}
	}